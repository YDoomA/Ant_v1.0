#include "SFML/Graphics.hpp"                                                    // Библиотека для работы с графикой
#include <iostream>                                                             // Библиотека для работы с консолью

using namespace sf;                                                             // Подключаем пространство имён sf(из sfml)
using namespace std;                                                            // Подключаем пространство имён std

class Ant                                                                       // Создаём класс
{
    public:                                                                     // Объявляем публичные переменные (координаты х, у,
        int x,y,n;                                                              // n - направление
        enum route{up = 1, left, down, right};                                  // Oбъявляем перечисление для направлений, чтоб не путаться
        Color _color;

        Ant(int X, int Y, int N, Color _Color)
        {                                                                       // Конструктор класса принимает начальные значения
            x = X; y = Y; n = N; _color = _Color;                               // Координаты Х, У и направление

        }
};

void rect_move (Ant &ant, bool **arr, sf::RectangleShape &rect, RenderWindow &app)// Функция для перемещения муравья
{                                                                               // принимает сслыку на экземпляр муравья,
                                                                                // ссылку на прямоугольник(для отображения муравья)
                                                                                // и ссылку на дескриптор окна.
    if(ant.x >= 10 && ant.x <= 799 && ant.y >= 10 && ant.y <= 599)              // Проверяем что муравей не упёрся в стенку
    {
        if(arr[ant.x][ant.y] != true)                                           // Проверяем, что текущее местоположение муравья
        {                                                                       // не является "true", т.е. муравей здесь ещё не был
            arr[ant.x][ant.y] = true;                                           // Отмечаем, что он сейчас здесь
            rect.setFillColor(ant._color);                                      // Меняем цвет
            ant.n++;                                                            // Меняем направление муравья влево.
            if(ant.n == 5)                                                      // Обнуляем наше перечисление
                ant.n=1;                                                        // В случае, если повернулись 4 раза.
        }

        else                                                                    // Проверяем,
        {                                                                       // Если муравей тут уже был,
            arr[ant.x][ant.y] = false;                                          // Отмечаем это в нашей матрице
            rect.setFillColor(Color::Black);                                    // Меняем цвет
            ant.n--;                                                            // Меняем направление муравья вправо
            if(ant.n == 0)                                                      // Обнуляем перечисление,
                ant.n=4;                                                        // Если 4 раза повернулись
        }

        switch (ant.n)                                                          // Перемещаем муравья
        {
            case ant.up:                                                        // В случае, если направление "вверх"
            ant.y -= 1;                                                         // Подтягиваем его на 1 пиксель вверх  !!Можно изменить
            rect.setPosition(ant.x,ant.y);                                      // Муравей, это маленький прямоугольник. Задаём его положение
            break;

            case ant.left:                                                      // В случае, если направление "влево"
            ant.x -= 1;                                                         // Подтягиваем его на 1 пиксель влево  !!Можно изменить
            rect.setPosition(ant.x,ant.y);                                      // Задаём положение муравья
            break;

            case ant.down:                                                      // В случае, если направление "вниз"
            ant.y += 1;                                                         // Подтягиваем его на 1 пиксель вниз  !!Можно изменить
            rect.setPosition(ant.x,ant.y);                                      // Задаём положение муравья
            break;

            case ant.right:                                                     // В случае, если направление "вправо"
            ant.x += 1;                                                         // Подтягиваем его на 1 пиксель вправо  !!Можно изменить
            rect.setPosition(ant.x,ant.y);                                      // Задаём положение муравья
            break;
        }
    app.draw(rect);
    }
}


int main()
{
    RenderWindow app(VideoMode(800, 600), "ANT v0.0");                           // Создаём окно 800х600 пикселей и даём ему название

    Clock clock;                                                                 // Cоздаем переменную времени, т.о. привязка ко времени(а не загруженности/мощности процессора).
    float time = 0;
    bool **arr = new bool* [800];                                                // Объявляем массив указателей на булевый массив
    for(int i=0; i< 800; i++)                                                    // Здесь, с помощью массивов создаём двухмерную матрицу
        {                                                                        // т.е. 800 пикселей по горизонтали и 600 по вертекали
            arr[i] = new bool[600];                                              // Это нужно, для хранения перемещений муравья
        }

    srand(clock.getElapsedTime().asMicroseconds());                              // для того, что бы муравьи появлялись рандомно
                                                                                 // привязываем srand к времени
    Ant ant0(400,300,1,Color::Blue);                                             // Создаём муравьёв( Это экземпляры класса Ant)
    Ant ant1(400,350,2,Color::Cyan);                                             // отправляем начальные координаты и направление
    Ant ant2(500,150,3,Color::Green);                                            // т.е один Ant муравей2(х=500,у=100, двигает вниз);
    Ant ant3(rand() % 700 +10,rand() % 500 +10,1,Color::Magenta);                // начальные координаты можно менять, задавая, где должны
    Ant ant4(rand() % 700 +10,rand() % 500 +10,2,Color::Red);                    // начинать своё движение муравьи
    Ant ant5(rand() % 700 +10,rand() % 500 +10,3,Color::White);                  // муравей 3 - 6 появляются в рандомных местах
    Ant ant6(rand() % 700 +10,rand() % 500 +10,1,Color::Yellow);
    RectangleShape _rectangle;                                                   // Объявляем прямоугольную фигуру, это наш муравей
    _rectangle.setSize(Vector2f(1,1));                                           // Задаём размер - 1х1 пиксель, можно увеличить его, но
                                                                                 // тогда нужно будет перемещать его на большее кол-во пикселей
                                                                                 // в функции выше.

    while (app.isOpen())                                                         // Это цикл, который работает пока открыто окно
    {
        Event event;                                                             // нужно для перехвата событий
        while (app.pollEvent(event))                                             // цикл ловящий события
        {
            if (event.type == sf::Event::Closed)                                 // если событие - закрытие окна
                {
                    for(int i=0; i<80; i++)                                      // начинаем чистить память, поскольку двухмерный
                    delete[] arr[i];                                             // массив был динамическим
                    delete[] arr;                                                // удалили полностью
                    app.close();                                                 // Закрываем приложение.
                }
        }

        float time = clock.getElapsedTime().asMicroseconds();                    //дать прошедшее время в микросекундах
        clock.restart();                                                         //перезагружает время

        app.display();                                                           // Здесь, отображаем на экране всё, что
        time = 0;                                                                // произошло в этой итерации

        rect_move(ant0, arr, _rectangle, app);                                   // вызываем функцию, двигающую каждого муравья
        rect_move(ant1, arr, _rectangle, app);
        rect_move(ant2, arr, _rectangle, app);
        rect_move(ant3, arr, _rectangle, app);
        rect_move(ant4, arr, _rectangle, app);
        rect_move(ant5, arr, _rectangle, app);
        rect_move(ant6, arr, _rectangle, app);

        sf::sleep(sf::milliseconds(5));                                        // Чтоб муравей не бегал слишком быстро, ставим небольшую задержку
        //cout << "\n\n\n\nX : "<< ant0.x <<"\n\nY: "
        //<< ant0.y << "\n\n\n\nX+400 : "<< ant0.x <<"\n\nY+400: " << ant0.y;      // отображаем в консоли местоположение центрального муравья
                                                                                 // это можно закомментировать, от этого функционал не упадёт
    }

    return EXIT_SUCCESS;
}
